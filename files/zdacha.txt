аутентификация¶ auth должен быть подключаемым. ‒ джейкоб каплан-мосс, «rest worst practices». аутентификация - это механизм связывания входящего запроса с набором идентификационных данных, таких как пользователь, от которого пришел запрос, или токен, которым он был подписан. политики permission и throttling могут затем использовать эти учетные данные для определения того, должен ли запрос быть разрешен. фреймворк rest предоставляет несколько схем аутентификации из коробки, а также позволяет реализовать пользовательские схемы. аутентификация всегда выполняется в самом начале представления, до того, как произойдет проверка разрешений и дросселирования, и до того, как будет разрешено выполнение любого другого кода. свойство request.user обычно устанавливается на экземпляр класса contrib.auth пакета user. свойство request.auth используется для любой дополнительной информации об аутентификации, например, оно может быть использовано для представления маркера аутентификации, которым был подписан запрос. примечание: не забывайте, что аутентификация сама по себе не разрешает и не запрещает входящий запрос, она просто идентифицирует полномочия, с которыми был сделан запрос. информацию о том, как настроить политику разрешений для вашего api, смотрите в разделе permissions documentation. как определяется аутентификация¶ схемы аутентификации всегда задаются в виде списка классов. rest framework попытается аутентифицироваться с каждым классом в списке, и установит request.user и request.auth, используя возвращаемое значение первого класса, который успешно аутентифицируется. если ни один класс не аутентифицируется, request.user будет установлен в экземпляр django.contrib.auth.models.anonymoususer , а request.auth будет установлен в none. значение request.user и request.auth для неаутентифицированных запросов может быть изменено с помощью параметров unauthenticated_user и unauthenticated_token. настройка схемы аутентификации¶ схемы аутентификации по умолчанию можно установить глобально, используя параметр default_authentication_classes. например. rest_framework = { 'default_authentication_classes': [ 'rest_framework.authentication.basicauthentication', 'rest_framework.authentication.sessionauthentication', ] } вы также можете установить схему аутентификации на основе каждого представления или каждого набора представлений, используя apiview представления на основе класса. from rest_framework.authentication import sessionauthentication, basicauthentication from rest_framework.permissions import isauthenticated from rest_framework.response import response from rest_framework.views import apiview class exampleview(apiview): authentication_classes = [sessionauthentication, basicauthentication] permission_classes = [isauthenticated] def get(self, request, format=none): content = { 'user': str(request.user),  `django.contrib.auth.user` instance. 'auth': str(request.auth),  none } return response(content) или, если вы используете декоратор @api_view с представлениями, основанными на функциях. @api_view(['get']) @authentication_classes([sessionauthentication, basicauthentication]) @permission_classes([isauthenticated]) def example_view(request, format=none): content = { 'user': str(request.user),  `django.contrib.auth.user` instance. 'auth': str(request.auth),  none } return response(content) неавторизованные и запрещенные ответы¶ когда неаутентифицированному запросу отказано в разрешении, существует два различных кода ошибок, которые могут быть уместны. http 401 unauthorized http 403 permission denied ответы http 401 всегда должны включать заголовок www-authenticate, который указывает клиенту, как пройти аутентификацию. ответы http 403 не включают заголовок www-authenticate. тип ответа, который будет использоваться, зависит от схемы аутентификации. хотя может использоваться несколько схем аутентификации, для определения типа ответа может использоваться только одна схема. первый класс аутентификации, установленный в представлении, используется при определении типа ответа. обратите внимание, что когда запрос может успешно пройти аутентификацию, но при этом получить отказ в разрешении на выполнение запроса, в этом случае всегда будет использоваться ответ 403 permission denied, независимо от схемы аутентификации. drfpasswordless¶ drfpasswordless добавляет (по мотивам medium, square cash) поддержку беспарольного входа в схему tokenauthentication платформы django rest framework. пользователи входят в систему и регистрируются с помощью токена, отправленного на контактную точку, например, адрес электронной почты или номер мобильного телефона. django-rest-authemail¶ django-rest-authemail предоставляет restful api интерфейс для регистрации и аутентификации пользователей. для аутентификации используются адреса электронной почты, а не имена пользователей. доступны конечные точки api для регистрации, проверки электронной почты при регистрации, входа в систему, выхода из системы, сброса пароля, проверки сброса пароля, изменения электронной почты, проверки изменения электронной почты, изменения пароля и детализации пользователя. полностью функциональный пример проекта и подробные инструкции прилагаются. джанго-рест-дурин¶ django-rest-durin создана с идеей иметь одну библиотеку, которая выполняет аутентификацию токенов для нескольких web/cli/mobile api клиентов через один интерфейс, но позволяет различную конфигурацию токенов для каждого api клиента, который потребляет api. она обеспечивает поддержку нескольких токенов для каждого пользователя через пользовательские модели, представления, разрешения, которые работают с django-rest-framework. время истечения срока действия токена может быть разным для каждого api клиента и настраивается через интерфейс администратора django. более подробную информацию можно найти в разделе documentation.